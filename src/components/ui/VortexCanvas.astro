---

---

<div class:list={['relative h-full w-full p-4']}>
	<div
		class:list={[
			'absolute h-full w-full inset-0 z-0 bg-transparent flex items-center justify-center'
		]}
	>
		<div class="absolute w-[250px] h-[250px] rounded-full gradient-background blur-2xl"></div>
		<canvas class="w-full h-full" data-vortex></canvas>
	</div>
	<div class="relative z-10">
		<slot />
	</div>
</div>

<script>
	class VortexAnimation {
		private canvas: HTMLCanvasElement
		private ctx: CanvasRenderingContext2D
		private particleProps: Float32Array
		private center: [number, number]
		private tick: number
		private animationFrame: number
		private noise3D: (x: number, y: number, z: number) => number

		private readonly HALF_PI = 0.5 * Math.PI
		private readonly TAU = 2 * Math.PI
		private readonly TO_RAD = Math.PI / 180

		constructor(
			canvas: HTMLCanvasElement,
			private config: {
				particleCount: number
				rangeY: number
				baseHue: number
				baseSpeed: number
				rangeSpeed: number
				baseRadius: number
				rangeRadius: number
				backgroundColor: string
			}
		) {
			this.canvas = canvas
			const ctx = canvas.getContext('2d')
			if (!ctx) throw new Error('Could not get canvas context')
			this.ctx = ctx

			this.center = [0, 0]
			this.tick = 0
			this.animationFrame = 0
			this.noise3D = this.createNoise3D()

			const particlePropCount = 9
			this.particleProps = new Float32Array(config.particleCount * particlePropCount)

			this.init()
		}

		private init(): void {
			this.resize()
			this.setupParticles()
			this.addEventListeners()
			this.startAnimation()
		}

		private createNoise3D(): (x: number, y: number, z: number) => number {
			const p = new Uint8Array(256)
			for (let i = 0; i < 256; i++) p[i] = i

			for (let i = 255; i > 0; i--) {
				const n = Math.floor((i + 1) * Math.random())
				const q = p[i]
				p[i] = p[n]
				p[n] = q
			}

			return (x: number, y: number, z: number) => {
				return Math.sin(x * 10 + y * 20 + z * 30) * Math.cos(x * 15 + y * 25 + z * 35) * 0.5 + 0.5
			}
		}

		private resize = (): void => {
			const rect = this.canvas.parentElement?.getBoundingClientRect()
			if (!rect) return

			const dpr = window.devicePixelRatio || 1
			this.canvas.width = rect.width * dpr
			this.canvas.height = rect.height * dpr
			this.ctx.scale(dpr, dpr)

			this.canvas.style.width = `${rect.width}px`
			this.canvas.style.height = `${rect.height}px`

			this.center = [rect.width / 2, rect.height / 2]
		}

		private setupParticles(): void {
			for (let i = 0; i < this.particleProps.length; i += 9) {
				this.initParticle(i)
			}
		}

		private initParticle(i: number): void {
			const x = this.rand(this.canvas.width)
			const y = this.center[1] + this.randRange(this.config.rangeY)
			const life = 0
			const ttl = 50 + this.rand(150)
			const speed = this.config.baseSpeed + this.rand(this.config.rangeSpeed)
			const radius = this.config.baseRadius + this.rand(this.config.rangeRadius)
			const hue = this.config.baseHue + this.rand(100)

			this.particleProps.set([x, y, 0, 0, life, ttl, speed, radius, hue], i)
		}

		private rand(n: number): number {
			return n * Math.random()
		}

		private randRange(n: number): number {
			return n - this.rand(2 * n)
		}

		private lerp(n1: number, n2: number, speed: number): number {
			return (1 - speed) * n1 + speed * n2
		}

		private fadeInOut(t: number, m: number): number {
			const hm = 0.5 * m
			return Math.abs(((t + hm) % m) - hm) / hm
		}

		private updateParticle(i: number): void {
			const xOff = 0.00125
			const yOff = 0.00125
			const zOff = 0.0005
			const noiseSteps = 3

			const x = this.particleProps[i]
			const y = this.particleProps[i + 1]

			const dx = x - this.center[0]
			const dy = y - this.center[1]
			const distanceToCenter = Math.sqrt(dx * dx + dy * dy)

			const attractionRadius = 200
			const attractionStrength = 0.08

			let vx, vy

			if (distanceToCenter < attractionRadius) {
				const force =
					((attractionRadius - distanceToCenter) / attractionRadius) * attractionStrength
				vx = this.lerp(this.particleProps[i + 2], -dx / distanceToCenter, force)
				vy = this.lerp(this.particleProps[i + 3], -dy / distanceToCenter, force)
			} else {
				const n = this.noise3D(x * xOff, y * yOff, this.tick * zOff) * noiseSteps * this.TAU
				vx = this.lerp(this.particleProps[i + 2], Math.cos(n), 0.5)
				vy = this.lerp(this.particleProps[i + 3], Math.sin(n), 0.5)
			}

			const life = this.particleProps[i + 4]
			const ttl = this.particleProps[i + 5]
			const speed = this.particleProps[i + 6]
			const radius = this.particleProps[i + 7]
			const hue = this.particleProps[i + 8]

			const x2 = x + vx * speed
			const y2 = y + vy * speed

			this.drawParticle(x, y, x2, y2, life, ttl, radius, hue)

			this.particleProps[i] = x2
			this.particleProps[i + 1] = y2
			this.particleProps[i + 2] = vx
			this.particleProps[i + 3] = vy
			this.particleProps[i + 4] = life + 1

			if (this.checkBounds(x2, y2) || life > ttl) {
				this.initParticle(i)
			}
		}

		private drawParticle(
			x: number,
			y: number,
			x2: number,
			y2: number,
			life: number,
			ttl: number,
			radius: number,
			hue: number
		): void {
			this.ctx.save()
			this.ctx.lineCap = 'round'
			this.ctx.lineWidth = radius
			this.ctx.strokeStyle = `hsla(${hue},100%,60%,${this.fadeInOut(life, ttl)})`
			this.ctx.beginPath()
			this.ctx.moveTo(x, y)
			this.ctx.lineTo(x2, y2)
			this.ctx.stroke()
			this.ctx.restore()
		}

		private checkBounds(x: number, y: number): boolean {
			return x > this.canvas.width || x < 0 || y > this.canvas.height || y < 0
		}

		private render(): void {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
			this.ctx.fillStyle = this.config.backgroundColor
			this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)

			for (let i = 0; i < this.particleProps.length; i += 9) {
				this.updateParticle(i)
			}

			this.renderGlow()
			this.renderToScreen()
		}

		private renderGlow(): void {
			this.ctx.save()
			this.ctx.filter = 'blur(8px) brightness(200%)'
			this.ctx.globalCompositeOperation = 'lighter'
			this.ctx.drawImage(this.canvas, 0, 0)
			this.ctx.restore()

			this.ctx.save()
			this.ctx.filter = 'blur(4px) brightness(200%)'
			this.ctx.globalCompositeOperation = 'lighter'
			this.ctx.drawImage(this.canvas, 0, 0)
			this.ctx.restore()
		}

		private renderToScreen(): void {
			this.ctx.save()
			this.ctx.globalCompositeOperation = 'lighter'
			this.ctx.drawImage(this.canvas, 0, 0)
			this.ctx.restore()
		}

		private animate = (): void => {
			this.tick++
			this.render()
			this.animationFrame = requestAnimationFrame(this.animate)
		}

		private startAnimation(): void {
			this.animate()
		}

		private addEventListeners(): void {
			window.addEventListener('resize', this.resize)
		}

		public destroy(): void {
			window.removeEventListener('resize', this.resize)
			cancelAnimationFrame(this.animationFrame)
		}
	}

	// Inicialization
	const vortexElements = document.querySelectorAll<HTMLCanvasElement>('[data-vortex]')
	const vortexInstances: VortexAnimation[] = []

	vortexElements.forEach((canvas) => {
		const config = {
			particleCount: 200,
			rangeY: 100,
			baseHue: 220,
			baseSpeed: 0.0,
			rangeSpeed: 1.5,
			baseRadius: 1,
			rangeRadius: 2,
			backgroundColor: 'transparent'
		}

		const instance = new VortexAnimation(canvas, config)
		vortexInstances.push(instance)
	})

	// Cleanup my Beautiful Effect
	document.addEventListener('astro:before-swap', () => {
		vortexInstances.forEach((instance) => instance.destroy())
	})
</script>
