---
title: 'Manejo de estado con URL en React usando nuqs'
img: '/posts/cover_post_2_es.webp'
description: 'Aprende a gestionar el estado de tu aplicación React con URLs utilizando el hook useQueryState de nuqs.'
published_at: '2025-02-13'
category: 'React'
slug: 'uso-querystate-nuqs'
---

¡Hey! 👋 ¿Te has preguntado alguna vez cómo esas apps tan cool mantienen su estado en la URL? Ya sabes, cuando filtras productos, haces una búsqueda o cambias de página, y puedes compartir ese link exacto con alguien más. Hoy vamos a ver cómo hacer eso en React usando `nuqs` - una librería súper útil que te va a hacer la vida más fácil.

## ¿Por qué deberías usar estados en la URL?

Normalmente usamos `useState` para todo en React (y está bien, no hay problema con eso). Pero gestionar el estado en la URL tiene algunas ventajas bastante interesantes:

- 🔥 **Compartir y mantener la UI**: Puedes pasarle la URL a tu amigo y verá exactamente lo mismo que tú
- 🔄 **Recargar sin miedo**: ¿Sabes cuando recargas la página y pierdes todo? Pues eso no pasa aquí
- 📱 **Multi-dispositivo friendly**: Abre la misma URL en tu celular y ¡boom! - mismo estado
- 🔙 **El botón de "atrás" funciona como debería**: Sin sorpresas raras al navegar
- 🤖 **Google te va a querer más**: Cada estado es una URL única que los bots pueden indexar

## Show me the code 👨‍💻

Empecemos con algo simple. Mira cómo se ve comparado con el clásico `useState`:

```jsx
'use client'

import { useQueryState } from 'nuqs'

export function Demo() {
	const [name, setName] = useQueryState('name')
	return (
		<>
			<input value={name || ''} onChange={(e) => setName(e.target.value)} />
			<button onClick={() => setName(null)}>Borrar</button>
			<p>¡Hola, {name || 'visitante misterioso'}! 👋</p>
		</>
	)
}
```

Sencillo pero, vamos a crear algo más real - una lista de productos con búsqueda y filtros, como las que ves en cualquier e-commerce decente:

```jsx
'use client'

import { useQueryState } from 'nuqs'

export function ProductList() {
	// Aquí manejamos todo el estado en la URL 🎯
	const [search, setSearch] = useQueryState('q')
	const [category, setCategory] = useQueryState('category')
	const [sortBy, setSortBy] = useQueryState('sort')
	const [page, setPage] = useQueryState('page', { defaultValue: '1' })

	// Imagina que esto viene de tu API favorita
	const products = [
		{ id: 1, name: 'MacBook Pro', category: 'electronics', price: 1299 },
		{ id: 2, name: 'iPhone 15', category: 'electronics', price: 999 }
		// ... más productos cool
	]

	// Un poco de magia para filtrar productos ✨
	const filteredProducts = products.filter((product) => {
		const matchesSearch = !search || product.name.toLowerCase().includes(search.toLowerCase())
		const matchesCategory = !category || product.category === category
		return matchesSearch && matchesCategory
	})

	return (
		<div className="container mx-auto p-4">
			{/* Barra de búsqueda con estilo */}
			<input
				type="text"
				value={search || ''}
				onChange={(e) => setSearch(e.target.value)}
				placeholder="¿Qué estás buscando? 🔍"
				className="border p-2 mb-4 rounded-lg"
			/>

			{/* Filtros para los exigentes */}
			<select
				value={category || ''}
				onChange={(e) => setCategory(e.target.value || null)}
				className="border p-2 mb-4 ml-2 rounded-lg"
			>
				<option value="">Todos los productos</option>
				<option value="electronics">Electrónicos</option>
				<option value="clothing">Ropa</option>
			</select>

			{/* Ordenar para los organizados */}
			<select
				value={sortBy || ''}
				onChange={(e) => setSortBy(e.target.value || null)}
				className="border p-2 mb-4 ml-2 rounded-lg"
			>
				<option value="">Ordenar por</option>
				<option value="price_asc">Precio: $ → $$$</option>
				<option value="price_desc">Precio: $$$ → $</option>
			</select>

			{/* Aquí van tus productos 📦 */}
			<div className="grid grid-cols-1 md:grid-cols-3 gap-4">
				{filteredProducts.map((product) => (
					<div
						key={product.id}
						className="border p-4 rounded-lg shadow-sm hover:shadow-md transition-shadow"
					>
						<h3 className="font-bold">{product.name}</h3>
						<p className="text-gray-600">{product.category}</p>
						<p className="text-green-600 font-bold">${product.price}</p>
					</div>
				))}
			</div>

			{/* Navegación entre páginas */}
			<div className="mt-4 flex justify-center gap-4">
				<button
					onClick={() => setPage(Math.max(1, Number(page) - 1).toString())}
					disabled={page === '1'}
					className="border p-2 rounded-lg hover:bg-gray-100"
				>
					← Anterior
				</button>
				<span className="py-2">Página {page}</span>
				<button
					onClick={() => setPage((Number(page) + 1).toString())}
					className="border p-2 rounded-lg hover:bg-gray-100"
				>
					Siguiente →
				</button>
			</div>
		</div>
	)
}
```

## 🚀 ¿Qué acabamos de hacer?

Cuando alguien use tu app, la URL se verá algo así:

```
/productos?q=macbook&category=electronics&sort=price_desc&page=2
```

¿No es hermoso? 😍 Cada parámetro de búsqueda, filtro y página está ahí, listo para ser compartido o guardado en marcadores.

## Pro tips

1. **No te pases con la URL**: Si tienes muchos filtros, considera cuáles son realmente importantes para compartir
2. **Piensa en el SEO**: Google ama las URLs limpias y significativas
3. **Dale un respiro al servidor**: Usa `throttleMs` para no hacer 50 peticiones por segundo mientras alguien escribe

```jsx
const [search, setSearch] = useQueryState('q', {
	history: 'push', // para navegación chida
	throttleMs: 300 // espera 300ms entre actualizaciones
})
```

Y eso es todo amigos! 🎉 Ahora ya sabes cómo hacer que tu app mantenga el estado en la URL como todo un pro. ¿Preguntas? ¡Déjalas en los comentarios!

PD: Si te gustó este post, compártelo con ese amigo que todavía usa `localStorage` para todo 😅
