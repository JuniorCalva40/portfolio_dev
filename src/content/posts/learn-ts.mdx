---
title: 'Manejo de estado con URL en React usando nuqs'
img: '/posts/cover_post_2_es.webp'
description: 'Aprende a gestionar el estado de tu aplicaciÃ³n React con URLs utilizando el hook useQueryState de nuqs.'
published_at: '2025-02-13'
category: 'React'
slug: 'uso-querystate-nuqs'
---

Â¡Hey! ğŸ‘‹ Â¿Te has preguntado alguna vez cÃ³mo esas apps tan cool mantienen su estado en la URL? Ya sabes, cuando filtras productos, haces una bÃºsqueda o cambias de pÃ¡gina, y puedes compartir ese link exacto con alguien mÃ¡s. Hoy vamos a ver cÃ³mo hacer eso en React usando `nuqs` - una librerÃ­a sÃºper Ãºtil que te va a hacer la vida mÃ¡s fÃ¡cil.

## Â¿Por quÃ© deberÃ­as usar estados en la URL?

Normalmente usamos `useState` para todo en React (y estÃ¡ bien, no hay problema con eso). Pero gestionar el estado en la URL tiene algunas ventajas bastante interesantes:

- ğŸ”¥ **Compartir y mantener la UI**: Puedes pasarle la URL a tu amigo y verÃ¡ exactamente lo mismo que tÃº
- ğŸ”„ **Recargar sin miedo**: Â¿Sabes cuando recargas la pÃ¡gina y pierdes todo? Pues eso no pasa aquÃ­
- ğŸ“± **Multi-dispositivo friendly**: Abre la misma URL en tu celular y Â¡boom! - mismo estado
- ğŸ”™ **El botÃ³n de "atrÃ¡s" funciona como deberÃ­a**: Sin sorpresas raras al navegar
- ğŸ¤– **Google te va a querer mÃ¡s**: Cada estado es una URL Ãºnica que los bots pueden indexar

## Show me the code ğŸ‘¨â€ğŸ’»

Empecemos con algo simple. Mira cÃ³mo se ve comparado con el clÃ¡sico `useState`:

```jsx
'use client'

import { useQueryState } from 'nuqs'

export function Demo() {
	const [name, setName] = useQueryState('name')
	return (
		<>
			<input value={name || ''} onChange={(e) => setName(e.target.value)} />
			<button onClick={() => setName(null)}>Borrar</button>
			<p>Â¡Hola, {name || 'visitante misterioso'}! ğŸ‘‹</p>
		</>
	)
}
```

Sencillo pero, vamos a crear algo mÃ¡s real - una lista de productos con bÃºsqueda y filtros, como las que ves en cualquier e-commerce decente:

```jsx
'use client'

import { useQueryState } from 'nuqs'

export function ProductList() {
	// AquÃ­ manejamos todo el estado en la URL ğŸ¯
	const [search, setSearch] = useQueryState('q')
	const [category, setCategory] = useQueryState('category')
	const [sortBy, setSortBy] = useQueryState('sort')
	const [page, setPage] = useQueryState('page', { defaultValue: '1' })

	// Imagina que esto viene de tu API favorita
	const products = [
		{ id: 1, name: 'MacBook Pro', category: 'electronics', price: 1299 },
		{ id: 2, name: 'iPhone 15', category: 'electronics', price: 999 }
		// ... mÃ¡s productos cool
	]

	// Un poco de magia para filtrar productos âœ¨
	const filteredProducts = products.filter((product) => {
		const matchesSearch = !search || product.name.toLowerCase().includes(search.toLowerCase())
		const matchesCategory = !category || product.category === category
		return matchesSearch && matchesCategory
	})

	return (
		<div className="container mx-auto p-4">
			{/* Barra de bÃºsqueda con estilo */}
			<input
				type="text"
				value={search || ''}
				onChange={(e) => setSearch(e.target.value)}
				placeholder="Â¿QuÃ© estÃ¡s buscando? ğŸ”"
				className="border p-2 mb-4 rounded-lg"
			/>

			{/* Filtros para los exigentes */}
			<select
				value={category || ''}
				onChange={(e) => setCategory(e.target.value || null)}
				className="border p-2 mb-4 ml-2 rounded-lg"
			>
				<option value="">Todos los productos</option>
				<option value="electronics">ElectrÃ³nicos</option>
				<option value="clothing">Ropa</option>
			</select>

			{/* Ordenar para los organizados */}
			<select
				value={sortBy || ''}
				onChange={(e) => setSortBy(e.target.value || null)}
				className="border p-2 mb-4 ml-2 rounded-lg"
			>
				<option value="">Ordenar por</option>
				<option value="price_asc">Precio: $ â†’ $$$</option>
				<option value="price_desc">Precio: $$$ â†’ $</option>
			</select>

			{/* AquÃ­ van tus productos ğŸ“¦ */}
			<div className="grid grid-cols-1 md:grid-cols-3 gap-4">
				{filteredProducts.map((product) => (
					<div
						key={product.id}
						className="border p-4 rounded-lg shadow-sm hover:shadow-md transition-shadow"
					>
						<h3 className="font-bold">{product.name}</h3>
						<p className="text-gray-600">{product.category}</p>
						<p className="text-green-600 font-bold">${product.price}</p>
					</div>
				))}
			</div>

			{/* NavegaciÃ³n entre pÃ¡ginas */}
			<div className="mt-4 flex justify-center gap-4">
				<button
					onClick={() => setPage(Math.max(1, Number(page) - 1).toString())}
					disabled={page === '1'}
					className="border p-2 rounded-lg hover:bg-gray-100"
				>
					â† Anterior
				</button>
				<span className="py-2">PÃ¡gina {page}</span>
				<button
					onClick={() => setPage((Number(page) + 1).toString())}
					className="border p-2 rounded-lg hover:bg-gray-100"
				>
					Siguiente â†’
				</button>
			</div>
		</div>
	)
}
```

## ğŸš€ Â¿QuÃ© acabamos de hacer?

Cuando alguien use tu app, la URL se verÃ¡ algo asÃ­:

```
/productos?q=macbook&category=electronics&sort=price_desc&page=2
```

Â¿No es hermoso? ğŸ˜ Cada parÃ¡metro de bÃºsqueda, filtro y pÃ¡gina estÃ¡ ahÃ­, listo para ser compartido o guardado en marcadores.

## Pro tips

1. **No te pases con la URL**: Si tienes muchos filtros, considera cuÃ¡les son realmente importantes para compartir
2. **Piensa en el SEO**: Google ama las URLs limpias y significativas
3. **Dale un respiro al servidor**: Usa `throttleMs` para no hacer 50 peticiones por segundo mientras alguien escribe

```jsx
const [search, setSearch] = useQueryState('q', {
	history: 'push', // para navegaciÃ³n chida
	throttleMs: 300 // espera 300ms entre actualizaciones
})
```

Y eso es todo amigos! ğŸ‰ Ahora ya sabes cÃ³mo hacer que tu app mantenga el estado en la URL como todo un pro. Â¿Preguntas? Â¡DÃ©jalas en los comentarios!

PD: Si te gustÃ³ este post, compÃ¡rtelo con ese amigo que todavÃ­a usa `localStorage` para todo ğŸ˜…
