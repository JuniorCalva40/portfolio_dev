---
title: 'Manejo de estado en React: Una guÃ­a prÃ¡ctica'
img: '/posts/cover_post_2_es.webp'
description: 'Recomendaciones para manejar el estado de tu aplicaciÃ³n React dependiendo del caso de uso'
published_at: '2025-02-13'
category: 'React'
slug: 'manejo-de-estado-en-react'
---

Si alguna vez has sentido que necesitas un mapa para navegar entre todas las opciones de manejo de estado en React, Â¡no estÃ¡s solo! En este post vamos a despejar tus dudas con ejemplos prÃ¡cticos de un e-commerce.

## 1. **Estado del Servidor: TanStack Query** ğŸš€

**Â¿CuÃ¡ndo usarlo?** Para cualquier dato que venga de tu backend (API REST o GraphQL).

### Ejemplos en un e-commerce:

- Listado de productos
- Detalle de producto y su disponibilidad
- ReseÃ±as de usuarios
- Historial de pedidos

TanStack Query es robusto porque:

- ğŸ”„ Mantiene cache y evita peticiones duplicadas
- ğŸ” Se integra perfectamente con paginaciÃ³n y filtrados
- ğŸ”® Revalida automÃ¡ticamente cuando es necesario

```jsx
import { useQuery } from '@tanstack/react-query'

export const FeaturedProducts = () => {
	const {
		data: products,
		isLoading,
		error
	} = useQuery({
		queryKey: ['featured-products'],
		queryFn: async () => {
			const res = await fetch('https://api.tutienda.com/productos/destacados')
			if (!res.ok) throw new Error('Error al cargar productos')
			return res.json()
		},
		staleTime: 5 * 60 * 1000 // Los datos se consideran frescos por 5 minutos
	})

	if (isLoading) return <ProductsSkeleton />
	if (error) return <ErrorMessage message="Â¡Ups! No pudimos cargar los productos" />

	return (
		<div className="grid-products">
			{products.map((product) => (
				<ProductCard key={product.id} product={product} />
			))}
		</div>
	)
}
```

> ğŸ”¥ **Pro tip:** No necesitas combinar TanStack Query con Zustand en la mayorÃ­a de casos. Â¿Por quÃ©? Porque TanStack Query ya maneja perfectamente el cachÃ©. Solo aÃ±ade Zustand si realmente necesitas manipular esos datos de formas complejas.

## 2. **Estado en la URL: El poder subestimado** ğŸ”—

**Â¿CuÃ¡ndo usarlo?** Para todo lo que el usuario deberÃ­a poder compartir o guardar en marcadores.

### Ejemplos en un e-commerce:

- ğŸ” Filtros de bÃºsqueda (categorÃ­a, precio, marca)
- ğŸ“„ PaginaciÃ³n
- ğŸ”¢ Opciones de de vista (grid/lista)
- ğŸ”¤ Ordenamiento de productos

```jsx
import { useQueryStates, parseAsString, parseAsInteger } from 'nuqs'

export function ProductSearch() {
	const [queryParams, setQueryParams] = useQueryStates({
		category: parseAsString.withDefault('all'),
		minPrice: parseAsInteger.withDefault(0),
		maxPrice: parseAsInteger.withDefault(1000),
		sort: parseAsString.withDefault('popularity')
	})

	// Ahora tu URL se ve como: ?category=electronics&minPrice=100&maxPrice=500&sort=price-asc

	return (
		<>
			<FilterSidebar filters={queryParams} onChange={setQueryParams} />

			<ProductGrid filters={queryParams} onPageChange={(page) => setQueryParams({ page })} />
		</>
	)
}
```

> ğŸ’¡ **Â¿Por quÃ© es tan bueno?** Cuando alguien comparte un link "Mira estos auriculares que filtrÃ© por menos de $50", la persona que lo recibe verÃ¡ exactamente los mismos resultados. AdemÃ¡s, puedes usar el botÃ³n de atrÃ¡s del navegador para volver a filtros anteriores.

## 3. **Estado Local: El clÃ¡sico useState()** ğŸ’¼

**Â¿CuÃ¡ndo usarlo?** Para estado temporal que solo importa en un componente especÃ­fico.

### Ejemplos en un e-commerce:

- ğŸ”˜ Toggle para mostrar/ocultar descripciÃ³n de producto
- ğŸ“ Formularios antes de enviarlos
- ğŸ–¼ï¸ Imagen seleccionada en un carrusel
- ğŸ›’ Cantidad seleccionada de un producto (antes de aÃ±adir al carrito)

```jsx
function ProductImageGallery({ images }) {
	const [currentImageIndex, setCurrentImageIndex] = useState(0)

	return (
		<div className="product-gallery">
			<img
				src={images[currentImageIndex]}
				alt={`Vista ${currentImageIndex + 1}`}
				className="main-image"
			/>

			<div className="thumbnails">
				{images.map((img, index) => (
					<button
						key={index}
						onClick={() => setCurrentImageIndex(index)}
						className={currentImageIndex === index ? 'active' : ''}
					>
						<img src={img} alt={`Miniatura ${index + 1}`} />
					</button>
				))}
			</div>
		</div>
	)
}
```

> âš ï¸ **Regla prÃ¡ctica:** Si mÃ¡s de un componente necesita acceder o modificar el mismo estado, probablemente useState() no sea la mejor opciÃ³n. Hora de subir de nivel...

## 4. **Estado Global: Zustand para la victoria** ğŸ†

**Â¿CuÃ¡ndo usarlo?** Para estado que debe compartirse entre componentes no relacionados directamente.

### Ejemplos en un e-commerce:

- ğŸ›’ Carrito de compras
- ğŸ‘¤ Datos del usuario autenticado
- ğŸ”” Notificaciones
- ğŸ’° Resumen de total a pagar

```jsx
import { create } from 'zustand'

// Creamos nuestro store
const useCartStore = create((set) => ({
	items: [],
	itemCount: 0,
	total: 0,

	// Acciones
	addItem: (product, quantity = 1) =>
		set((state) => {
			const existingItem = state.items.find((item) => item.id === product.id)

			if (existingItem) {
				// Actualizar cantidad si ya existe
				const updatedItems = state.items.map((item) =>
					item.id === product.id ? { ...item, quantity: item.quantity + quantity } : item
				)
				return {
					items: updatedItems,
					itemCount: state.itemCount + quantity,
					total: state.total + product.price * quantity
				}
			} else {
				// AÃ±adir nuevo item
				return {
					items: [...state.items, { ...product, quantity }],
					itemCount: state.itemCount + quantity,
					total: state.total + product.price * quantity
				}
			}
		}),

	removeItem: (productId) =>
		set((state) => {
			const itemToRemove = state.items.find((item) => item.id === productId)
			if (!itemToRemove) return state

			return {
				items: state.items.filter((item) => item.id !== productId),
				itemCount: state.itemCount - itemToRemove.quantity,
				total: state.total - itemToRemove.price * itemToRemove.quantity
			}
		}),

	clearCart: () => set({ items: [], itemCount: 0, total: 0 })
}))

// Componente que usa el carrito
function AddToCartButton({ product }) {
	const [quantity, setQuantity] = useState(1)
	const addItem = useCartStore((state) => state.addItem)

	return (
		<div>
			<QuantitySelector value={quantity} onChange={setQuantity} />
			<button
				onClick={() => {
					addItem(product, quantity)
					toast.success(`Â¡${product.name} aÃ±adido al carrito!`)
				}}
			>
				AÃ±adir al carrito
			</button>
		</div>
	)
}

// Componente en otra parte de la app
function CartIcon() {
	const itemCount = useCartStore((state) => state.itemCount)

	return (
		<Link to="/cart">
			<div className="cart-icon">
				<ShoppingBagIcon />
				{itemCount > 0 && <span className="badge">{itemCount}</span>}
			</div>
		</Link>
	)
}
```

> ğŸš€ **Por quÃ© Zustand es genial:**
>
> - Simple y no invasivo - no necesitas Providers
> - Funciona con cualquier parte de tu app
> - Menos boilerplate que Redux
> - Perfecto para estados de UI compartidos

## ğŸ“‹ Tabla comparativa: Â¿CuÃ¡ndo usar cada opciÃ³n?

| Estrategia         | Usa cuando necesites...                                              | Evita cuando...                                     | Ejemplos en e-commerce                              |
| ------------------ | -------------------------------------------------------------------- | --------------------------------------------------- | --------------------------------------------------- |
| **TanStack Query** | Datos de APIs, cachÃ© optimizada, revalidaciones                      | Estado de UI puro, datos que no vienen del servidor | CatÃ¡logo de productos, reseÃ±as, datos de usuario    |
| **Estado en URL**  | Compartir enlaces, mantener estado en recarga, navegar con historial | Datos privados o sensibles                          | Filtros, paginaciÃ³n, configuraciÃ³n de vista         |
| **useState**       | Estado simple y aislado en un componente                             | Compartir ese estado con otros componentes          | Formularios locales, toggles UI, selecciÃ³n temporal |
| **Zustand**        | Estado compartido entre mÃºltiples componentes                        | El estado solo es relevante para un componente      | Carrito, autenticaciÃ³n, preferencias globales       |

## ğŸ¯ ConclusiÃ³n:

1. **Combina estrategias:** En algunos casos donde la lÃ³gica se maneja en el servidor, TanStack Query es genial y puede cubrir la mayorÃ­a de los casos. En otros casos, tendrÃ¡s que combinarlo con un state management como Zustand, por ejemplo, cuando necesites mantener estados compartidos en el cliente, como el estado del carrito de compras o la autenticaciÃ³n del usuario. TambiÃ©n podrÃ­as usar React Context para valores que rara vez cambian, como temas o configuraciones globales. La clave estÃ¡ en saber dÃ³nde aplicar cada una.

2. **Manten la simplicidad:** No uses Zustand si useState es suficiente. No uses TanStack Query para datos que no vienen del servidor.

3. **Optimiza la experiencia:** El estado en URL mejora la experiencia del usuario permitiendo compartir y guardar estados especÃ­ficos.

4. **Piensa en la escala:** Lo que funciona para una tienda pequeÃ±a puede no ser suficiente cuando tienes miles de productos y usuarios.
